title: A Git Book
date: 2017-08-10
tags: [Git]
---
Git是一个开源的分布式版本控制软件.自诞生以来,Git就以其开源,简单,快捷,分布式,高效等特点,应付了类似Linux内核源代码等各种复杂的项目开发需求.如今,Git已经非常成熟,被广泛接受与使用,越来越多的项目都迁移到Git仓库中进行管理.

<!--more-->
## 回滚
```
git log -3
git reset --hard xxx
```

## Connecting with SSH
```bash
ssh-keygen -t rsa -C "flystarhe@qq.com"
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub
```

添加到公钥认证管理,执行`ssh -T git@github.com`或`ssh -T git@gitee.com`完成测试.要正式享受该福利,还需要以SSH方式克隆项目,而不是HTTPS.

## Git仓库
有两种取得Git项目仓库的方法.第一种是在现有项目或目录下导入所有文件到Git中;第二种是从一个服务器克隆一个现有的Git仓库.

### 在现有目录中初始化仓库
如果你打算使用Git来对现有的项目进行管理,你只需要进入该项目目录并输入:

    $ git init

该命令将创建一个名为`.git`的子目录,这个子目录含有你初始化的Git仓库中所有的必须文件,这些文件是Git仓库的骨干.但是,在这个时候,我们仅仅是做了一个初始化的操作,你的项目里的文件还没有被跟踪.

如果你是在一个已经存在文件的文件夹,而不是空文件夹,中初始化Git仓库来进行版本控制的话,你应该开始跟踪这些文件并提交.你可通过`git add`命令来实现对指定文件的跟踪,然后执行`git commit`提交:

    $ git add *.c
    $ git add LICENSE
    $ git commit -m 'initial project version'

### 克隆现有的仓库
如果你想获得一份已经存在了的Git仓库的拷贝,比如说,你想为某个开源项目贡献自己的一份力,这时就要用到`git clone`命令.当你执行`git clone`命令的时候,默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来.事实上,如果你的服务器的磁盘坏掉了,你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库,详见[在服务器上搭建Git](https://git-scm.com/book/zh/v2/ch00/_git_on_the_server).

克隆仓库的命令格式是`git clone [url]`.比如,要克隆Git的可链接库libgit2,可以用下面的命令:

    $ git clone https://github.com/libgit2/libgit2

这会在当前目录下创建一个名为`libgit2`的目录,并在这个目录下初始化一个`.git`文件夹,从远程仓库拉取下所有数据放入`.git`文件夹,然后从中读取最新版本的文件的拷贝.如果你进入到这个新建的`libgit2`文件夹,你会发现所有的项目文件已经在里面了,准备就绪等待后续的开发和使用.如果你想在克隆远程仓库的时候,自定义本地仓库的名字,你可以使用如下命令:

    $ git clone https://github.com/libgit2/libgit2 mylibgit

### 工作区和暂存区
工作区有一个隐藏目录`.git`,这个不算工作区,而是Git的版本库.Git的版本库里存了很多东西,其中最重要的就是称为stage或index的暂存区,还有Git为我们自动创建的第一个分支master,以及指向master的一个指针叫HEAD.

- `git add`把文件添加进去,实际上就是把文件修改添加到暂存区
- `git commit`提交更改,实际上就是把暂存区的所有内容提交到当前分支

## 记录更新
现在我们手上有了一个真实项目的Git仓库,并从这个仓库中取出了所有文件的工作拷贝.接下来,对这些文件做些修改,在完成了一个阶段的目标之后,提交本次更新到仓库.

请记住,你工作目录下的每一个文件都不外乎这两种状态:已跟踪或未跟踪.已跟踪的文件是指那些被纳入了版本控制的文件,在上一次快照中有它们的记录,在工作一段时间后,它们的状态可能处于未修改,已修改或已放入暂存区.工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件,它们既不存在于上次快照的记录中,也没有放入暂存区.初次克隆某个仓库的时候,工作目录中的所有文件都属于已跟踪文件,并处于未修改状态.

### 检查当前文件状态
要查看哪些文件处于什么状态,可以用`git status`命令.如果在克隆仓库后立即使用此命令,会看到类似这样的输出:

    $ git status
    On branch master
    nothing to commit, working directory clean

这说明你现在的工作目录相当干净.换句话说,所有已跟踪文件在上次提交后都未被更改过.此外,上面的信息还表明,当前目录下没有出现任何处于未跟踪状态的新文件,否则Git会在这里列出来.最后,该命令还显示了当前所在分支,并告诉你这个分支同远程服务器上对应的分支没有偏离.现在,分支名是`master`,这是默认的分支名.

现在,让我们在项目下创建一个新的`README`文件.如果之前并不存在这个文件,使用`git status`命令,你将看到一个新的未跟踪文件`README`.只要在`Untracked files`这行下面,就说明是未跟踪状态.未跟踪的文件意味着Git在之前的快照(提交)中没有这些文件.Git不会自动将之纳入跟踪范围,除非你明明白白地告诉它.

`git status`命令的输出十分详细,但其用语有些繁琐.如果你使用`git status -s`命令或`git status --short`命令,你将得到一种更为紧凑的格式输出.新添加的未跟踪文件前面有`??`标记,新添加到暂存区中的文件前面有`A`标记,修改过的文件前面有`M`标记.你可能注意到了`M`有两个可以出现的位置,出现在右边的`M`表示该文件被修改了但是还没放入暂存区,出现在靠左边的`M`表示该文件被修改了并放入了暂存区.

### 跟踪文件
使用命令`git add`开始跟踪一个文件.要跟踪`README`文件:

    $ git add README

`git add`命令使用文件或目录的路径作为参数.如果参数是目录的路径,该命令将递归地跟踪该目录下的所有文件.这是个多功能命令:可以用它开始跟踪新文件,或者把已跟踪的文件放到暂存区,还能用于合并时把有冲突的文件标记为已解决状态等.将这个命令理解为"添加内容到下一次提交中"而不是"将一个文件添加到项目中"要更加合适.

此时再运行`git status`命令,会看到`README`文件已被跟踪,并处于暂存状态.只要在`Changes to be committed`这行下面的,就说明是已暂存状态.

### 忽略文件
一般我们总会有些文件无需纳入Git的管理,也不希望它们总出现在未跟踪文件列表.通常都是些自动生成的文件,比如日志文件,或者编译过程中创建的临时文件等.在这种情况下,我们可以创建一个名为`.gitignore`的文件,列出要忽略的文件模式.来看一个实际的例子:

    $ cat .gitignore
    *.[oa]
    *~

第一行告诉Git忽略所有以`.o`或`.a`结尾的文件,第二行告诉Git忽略所有以波浪符`~`结尾的文件.星号`*`匹配零个或多个任意字符;`[abc]`匹配任何一个列在方括号中的字符;问号`?`匹配一个任意字符;如果在方括号中使用短划线分隔两个字符,表示所有在这两个字符范围内的都可以匹配,比如`[0-9]`;使用两个星号`*`表示匹配任意中间目录,比如`a/**/z`可以匹配`a/z`,`a/b/z`或`a/b/c/z`.

### 查看修改
你想知道具体修改了什么地方?尽管`git status`已经通过在相应栏下列出文件名的方式回答了这个问题,`git diff`将通过文件补丁的格式显示具体哪些行发生了改变.要查看尚未暂存的文件更新了哪些部分,不加参数直接输入`git diff`.此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容.

- `git diff`查看尚未暂存的文件更新了哪些部分
- `git diff HEAD`查看未暂存文件与最新提交文件快照的区别
- `git diff --cached`查看已暂存文件和上次提交时的快照之间的差异
- `git diff <index1> <index2>`查看不同快照之间的区别

### 提交更新
现在的暂存区域已经准备妥当可以提交了.在此之前,请一定要确认还有什么修改过的或新建的文件还没有`git add`过,否则提交的时候不会记录这些还没暂存起来的变化.这些修改过的文件只保留在本地磁盘.所以,每次准备提交前,先用`git status`看下,是不是都已暂存起来了,然后再运行提交命令`git commit -m 'added new benchmarks'`.

尽管使用暂存区域的方式可以精心准备要提交的细节,但有时候这么做略显繁琐,Git提供了一个跳过使用暂存区域的方式,只要在提交的时候,给`git commit`加上`-a`选项,Git就会自动把所有已经跟踪过的文件暂存起来一并提交,从而跳过`git add`步骤.

    $ git commit -a -m 'added new benchmarks'

### 移除文件
可以用`git rm`命令完成此项工作,并连带从工作目录中删除指定的文件,这样以后就不会出现在未跟踪文件清单中了.下一次提交时,该文件就不再纳入版本管理了.如果删除之前修改过并且已经放到暂存区域的话,则必须要用强制删除选项`-f`.

### 移动文件
当你看到Git的`mv`命令时一定会困惑不已.要在Git中对文件改名,可以这么做:

    $ git mv file_from file_to

## 远程仓库的使用
为了能在任意Git项目上协作,你需要知道如何管理自己的远程仓库.与他人协作涉及管理远程仓库以及根据需要推送或拉取数据.管理远程仓库包括了解如何添加远程仓库,移除无效的远程仓库,管理不同的远程分支并定义它们是否被跟踪等等.

### 查看远程仓库
如果想查看你已经配置的远程仓库服务器,可以运行`git remote`命令.如果你已经克隆了自己的仓库,那么至少应该能看到`origin`,这是Git给你克隆的仓库服务器的默认名字.你也可以指定选项`-v`,会显示需要读写远程仓库使用的Git保存的简写与其对应的URL.

### 添加远程仓库
我在之前已经提到并展示了如何添加远程仓库的示例,不过这里将告诉你如何明确地做到这一点.运行`git remote add <shortname> <url>`添加一个新的远程Git仓库,同时指定一个你可以轻松引用的简写:

    $ git remote add origin https://github.com/paulboone/ticgit

现在你可以在命令行中使用字符串`origin`来代替整个`URL`.如果你使用clone命令克隆了一个仓库,会自动将其添加为远程仓库并默认以`origin`为简写.

### 从远程仓库中抓取与拉取
从远程仓库中获得数据,可以执行:

    $ git fetch [remote-name]

`git fetch`命令会将数据拉取到你的本地仓库,它并不会自动合并或修改你当前的工作.当准备好时你必须手动将其合并入你的工作.

如果你有一个分支设置为跟踪一个远程分支,可以使用`git pull`命令来自动的抓取然后合并远程分支到当前分支.默认情况下,`git clone`命令会自动设置本地master分支跟踪克隆的远程仓库的master分支,或不管是什么名字的默认分支.运行`git pull`通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支.

### 推送到远程仓库
当你想分享你的项目时,必须将其推送到上游.这个命令很简单`git push [remote-name] [branch-name]`.当你想要将master分支推送到origin服务器时:

    $ git push origin master

只有当你有所克隆服务器的写入权限,并且之前没有人推送过时,这条命令才能生效.当你和其他人在同一时间克隆,他们先推送到上游然后你再推送到上游,你的推送就会毫无疑问地被拒绝.你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送.

### 查看远程仓库
如果想要查看某一个远程仓库的更多信息,可以使用`git remote show [remote-name]`命令.它同样会列出远程仓库的URL与跟踪分支的信息.这些信息非常有用,当你在特定的分支上执行`git push`会自动地推送到哪一个远程分支,它也同样地列出了哪些远程分支不在你的本地,哪些远程分支已经从服务器上移除了,还有当你执行`git pull`时哪些分支会自动合并.

## 分支
有人把Git的分支模型称为它的`必杀技特性`,也正因为这一特性,使得Git从众多版本控制系统中脱颖而出.

### 分支创建
比如,创建一个`testing`分支,你需要使用`git branch`命令:

    $ git branch testing

`git branch`命令仅仅创建一个新分支,并不会自动切换到新分支中去.

### 分支切换
要切换到一个已存在的分支,你需要使用`git checkout`命令:

    $ git checkout testing

### 分支删除
使用`git branch -d`命令实现分支删除:

    $ git branch -d testing

### 分支管理
`git branch`命令不只是可以创建与删除分支.如果不加任何参数运行它,会得到当前所有分支的一个列表:

    $ git branch
      iss53
    * master
      testing

注意master分支前的`*`字符:它代表现在检出的那一个分支,也就是说当前HEAD指针所指向的分支.这意味着如果在这时候提交,master分支将会随着新的工作向前移动.如果需要查看每一个分支的最后一次提交,可以运行`git branch -v`命令.

`--merged`与`--no-merged`这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支.如果要查看哪些分支已经合并到当前分支,可以运行`git branch --merged`:

    $ git branch --merged
      iss53
    * master

因为之前已经合并了`iss53`分支,所以现在看到它在列表中.在这个列表中分支名字前没有`*`号的分支通常可以使用`git branch -d`删除掉.你已经将它们的工作整合到了另一个分支,所以并不会失去任何东西.

查看所有包含未合并工作的分支,可以运行`git branch --no-merged`:

    $ git branch --no-merged
      testing

这里显示了其他分支.因为它包含了还未合并的工作,尝试使用`git branch -d`命令删除它时会失败.如果真的想要删除分支并丢掉那些工作,可以使用`-D`选项强制删除它.

## 实战
实际工作中你可能会用到类似的工作流,你将经历如下步骤:

- 开发某个网站
- 为实现某个新的需求,创建一个分支
- 在这个分支上开展工作

正在此时,你突然接到一个电话说有个很严重的问题需要紧急修补:

- 切换到你的线上分支
- 为这个紧急任务新建一个分支,并在其中修复它
- 在测试通过之后,切换回线上分支,然后合并这个修补分支,最后将改动推送到线上分支
- 切换回你最初工作的分支上,继续工作

首先,我们假设你正在你的项目上工作,并且已经有一些提交.现在,你已经决定要解决你的公司使用的问题追踪系统中的`#53`问题.想要新建一个分支并同时切换到那个分支上:

    $ git checkout -b iss53

你继续在`#53`问题上工作,并且做了一些提交.在此过程中,`iss53`分支在不断的向前推进,因为你已经检出到该分支,也就是说你的HEAD指针指向了`iss53`分支.

现在你接到那个电话,有个紧急问题等待你来解决.有了Git的帮助,你不必把这个紧急问题和`iss53`的修改混在一起,你也不需要花大力气来还原关于`#53`问题的修改,然后再添加关于这个紧急问题的修改,最后将这个修改提交到线上分支.你所要做的仅仅是切换回master分支.

但是,在你这么做之前,要留意你的工作目录和暂存区里那些还没有被提交的修改,它可能会和你即将检出的分支产生冲突从而阻止Git切换到该分支.最好的方法是,在你切换分支之前,保持好一个干净的状态.现在,我们假设你已经把你的修改全部提交了,这时你可以切换回master分支了:

    $ git checkout master

这个时候,你的工作目录和你在开始`#53`问题之前一模一样,现在你可以专心修复紧急问题了.请牢记:当你切换分支的时候,Git会重置你的工作目录,使其看起来像回到了你在那个分支上最后一次提交的样子.Git会自动添加,删除,修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样.

接下来,你要修复这个紧急问题.让我们建立一个针对该紧急问题的分支(hotfix branch),在该分支上工作直到问题解决:

    $ git checkout -b hotfix
    ...
    $ git commit -a -m 'fixed the ...'

你可以运行你的测试,确保你的修改是正确的,然后将其合并回你的master分支来部署到线上.你可以使用`git merge`命令来达到上述目的:

    $ git checkout master
    $ git merge hotfix

在合并的时候,你应该注意到了`快进,fast-forward`这个词.由于当前master分支所指向的提交是你当前提交的直接上游,所以Git只是简单的将指针向前移动.换句话说,当你试图合并两个分支时,如果顺着一个分支走下去能够到达另一个分支,那么Git在合并两者的时候,只会简单的将指针向前推进,因为这种情况下的合并操作没有需要解决的分歧,这就叫做`快进,fast-forward`.

现在,最新的修改已经在master分支所指向的提交快照中,你可以着手发布该修复了.关于这个紧急问题的解决方案发布之后,你准备回到被打断之前时的工作中.然而,你应该先删除hotfix分支,因为你已经不再需要它了,master分支已经指向了同一个位置.你可以使用带`-d`选项的`git branch`命令来删除分支:

    $ git branch -d hotfix

现在你可以切换回你正在工作的分支继续你的工作,也就是针对`#53`问题的那个分支`iss53`:

    $ git checkout iss53
    ...
    $ git commit -a -m 'finished the new footer [issue 53]'

你在hotfix分支上所做的工作并没有包含到`iss53`分支中.如果你需要拉取hotfix所做的修改,你可以使用`git merge master`命令将master分支合并入`iss53`分支,或者你也可以等到`iss53`分支完成其使命,再将其合并回master分支.

假设你已经修正了`#53`问题,并且打算将你的工作合并入master分支.为此,你需要合并`iss53`分支到master分支,这和之前你合并hotfix分支所做的工作差不多.你只需要检出到你想合并入的分支,然后运行`git merge`命令:

    $ git checkout master
    $ git merge iss53

这和你之前合并hotfix分支的时候看起来有一点不一样.在这种情况下,你的开发历史从一个更早的地方开始分叉.因为,master分支所在提交并不是`iss53`分支所在提交的直接祖先,Git不得不做一些额外的工作.出现这种情况的时候,Git会使用两个分支的末端所指的快照以及这两个分支的工作祖先,做一个简单的三方合并.

![](git-guide01.png)

和之前将分支指针向前推进所不同的是,Git将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它.这个被称作一次合并提交,它的特别之处在于他有不止一个父提交.

![](git-guide02.png)

既然你的修改已经合并进来了,你已经不再需要`iss53`分支了.现在你可以在任务追踪系统中关闭此项任务,并删除这个分支.

### 冲突解决
有时候合并操作会不顺利.如果你在两个不同的分支中,对同一个文件的同一个部分进行了不同的修改,Git就没法干净的合并它们.如果你对`#53`问题的修改和有关`hotfix`的修改都涉及到同一个文件的同一处,在合并它们的时候就会产生合并冲突:

    $ git merge iss53
    Auto-merging index.html
    CONFLICT (content): Merge conflict in index.html
    Automatic merge failed; fix conflicts and then commit the result.

此时Git做了合并,但是没有自动地创建一个新的合并提交.Git会暂停下来,等待你去解决合并产生的冲突.你可以在合并冲突后的任意时刻使用`git status`命令来查看那些因包含合并冲突而处于未合并`unmerged`状态的文件.任何因包含合并冲突而有待解决的文件,都会以未合并状态标识出来.Git会在有冲突的文件中加入标准的冲突解决标记,这样你可以打开这些包含冲突的文件然后手动解决冲突.出现冲突的文件会包含一些特殊区段,看起来像下面这个样子:

    <<<<<<< HEAD:index.html
    <div id="footer">contact : email.support@github.com</div>
    =======
    <div id="footer">
     please contact us at support@github.com
    </div>
    >>>>>>> iss53:index.html

这表示HEAD所指示的版本在这个区段的上半部分,而`iss53`分支所指示的版本在`=======`的下半部分.为了解决冲突,你必须选择使用由`=======`分割的两部分中的一个,或者你也可以自行合并这些内容.例如,你可以通过把这段内容换成下面的样子来解决冲突:

    <div id="footer">
    please contact us at email.support@github.com
    </div>

上述的冲突解决方案仅保留了其中一个分支的修改,并且`<<<<<<<`,`=======`和`>>>>>>>`这些行被完全删除了.在你解决了所有文件里的冲突之后,对每个文件使用`git add`命令来将其标记为冲突已解决.一旦暂存这些原本有冲突的文件,Git就会将它们标记为冲突已解决.这时你可以输入`git commit`来完成合并提交.

如果你想使用图形化工具来解决冲突,你可以运行`git mergetool`,该命令会为你启动一个合适的可视化合并工具,并带领你一步一步解决这些冲突.

## 多人协作
当你从远程仓库克隆时,实际上Git自动把本地的master分支和远程的master分支对应起来了,并且远程仓库的默认名称是origin.要查看远程库的信息,用`git remote`,或者`git remote -v`显示更详细的信息.

### 推送分支
推送分支,就是把该分支上的所有本地提交推送到远程库.推送时,要指定本地分支:
```
git push origin master
```

如果要推送其他分支,比如dev:
```
git push origin dev
```

并不是一定要把本地分支往远程推送.那么,哪些分支需要推送,哪些不需要呢?

- master分支是主分支,要时刻与远程同步
- dev分支是开发分支,团队所有成员都需要在上面工作,也需要与远程同步
- bug分支用于在本地修复bug,就没必要推到远程了
- feature分支是否推到远程,取决于你是否和你的小伙伴合作在上面开发

### 抓取分支
多人协作时,大家都会往master和dev分支上推送各自的修改.现在,模拟一个你的小伙伴,可以在另一台电脑或者同一台电脑的另一个目录下克隆.当你的小伙伴从远程库clone时,默认情况下,你的小伙伴只能看到本地的master分支.不信可以用`git branch`命令看看.现在,你的小伙伴要在dev分支上开发,就必须创建远程origin的dev分支到本地,于是他用这个命令创建本地dev分支:
```
git checkout -b dev origin/dev
```

现在,他就可以在dev上继续修改.然后,时不时地把dev分支push到远程:
```
git commit -m "add /usr/bin/env"
git push origin dev
```

你的小伙伴已经向`origin/dev`分支推送了他的提交,而碰巧你也对同样的文件作了修改,并试图推送:
```
git add hello.py
git commit -m "add coding: utf-8"
git push origin dev
```

推送失败,因为你的小伙伴的最新提交和你试图推送的提交有冲突.解决办法也很简单,Git已经提示我们,先用`git pull`把最新的提交从`origin/dev`抓下来.然后,在本地合并,解决冲突,再推送:
```
git pull
```

`git pull`也失败了,原因是没有指定本地dev分支与远程`origin/dev`分支的链接,根据提示,设置dev和`origin/dev`的链接:
```
git branch --set-upstream dev origin/dev
```

再pull:
```
git pull
```

这回`git pull`成功,但是合并有冲突,需要手动解决,解决的方法和分支管理中的解决冲突完全一样.解决后,再push:
```
git commit -m "merge & fix hello.py"
git push origin dev
```

### 小结
因此,多人协作的工作模式通常是这样:

- 首先,试图用`git push origin branch-name`推送自己的修改
- 如果推送失败,因为远程分支比你的本地更新,尝试用`git pull`合并
- 如果合并有冲突,则解决冲突,并在本地提交
- 没有冲突后,再用`git push origin branch-name`推送

如果`git pull`提示`no tracking information`,则说明本地分支和远程分支的链接关系没有创建,用命令`git branch --set-upstream branch-name origin/branch-name`.在本地创建和远程分支对应的分支,使用`git checkout -b branch-name origin/branch-name`,本地和远程分支的名称最好一致.

## 参考资料:
- [Git Book zh](https://git-scm.com/book/zh/v2)
- [Git 之旅](https://www.ibm.com/developerworks/cn/opensource/os-cn-tourofgit/index.html)