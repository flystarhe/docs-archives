title: TextRank探索与实践
date: 2016-08-15
tags: [TextRank,PageRank]
---
TextRank算法基于PageRank，用于为文本生成关键字和摘要。谈起自动摘要算法，常见的并且最易实现的当属TF-IDF，但是感觉TF-IDF效果一般，不如TextRank好。

<!--more-->
## PageRank
PageRank最开始用来计算网页的重要性。整个www可以看作一张有向图，节点是网页。如果网页A存在到网页B的链接，那么有一条从网页A指向网页B的有向边。构造完图后，使用下面的公式：

\begin{align}
S(V_i) = (1 - d) + d * \sum_{j \in In(V_i)} \frac{1}{|Out(V_j)|} S(V_j)
\end{align}

`S(V_i)`是网页i的PR值。d是阻尼系数，一般设置为0.85。`In(V_i)`是存在指向网页i的链接的网页集合。`Out(V_j)`是网页j中的链接存在的链接指向的网页的集合。`|Out(V_j)|`是集合中元素的个数。PageRank需要使用上面的公式多次迭代才能得到结果。初始时，可以设置每个网页的重要性为1。

## TextRank
TextRank一般模型可以表示为一个有向有权图`G = (V, E)`，由点集合V和边集合E组成，E是`V×V`的子集。图中任两点`V_i`、`V_j`之间边的权重为`w_ji`，对于一个给定的点`V_i`，`In(V_i)`为指向该点的点集合，`Out(V_i)`为点`V_i`指向的点集合。点`V_i`的得分定义如下：

\begin{align}
WS(V_i) = (1 - d) + d * \sum_{V_j \in In(V_i)} \frac{w_{ji}}{\sum_{V_k \in Out(V_j)} w_{jk}} WS(V_j)
\end{align}

其中，d为阻尼系数，取值范围为0到1，代表从图中某一特定点指向其他任意点的概率，一般取值为0.85。使用TextRank算法计算图中各点的得分时，需要给图中的点指定任意的初值，并递归计算直到收敛，即图中任意一点的误差率小于给定的极限值时就可以达到收敛，一般该极限值取0.0001。

## TextRank提取关键字
将原文本分词，然后过滤掉停用词（可选），并只保留指定词性的单词（可选，去掉了标点符号、常用词、以及名词、动词、形容词、副词之外的词）。每个单词作为一个节点，设定窗口大小为k，在一个窗口中的任两个单词对应的节点之间存在一个无向无权的边`w_ji = 1`。基于上面构成图，可以计算出每个单词节点的重要性。最重要的若干单词可以作为关键词。

先看看测试数据：
```
程序员(英文Programmer)是从事程序开发、维护的专业人员。
一般将程序员分为程序设计人员和程序编码人员，但两者的界限并不非常清楚，特别是在中国。
软件从业人员分为初级程序员、高级程序员、系统分析员和项目经理四大类。
```

首先对这句话分词，得出分词结果：
```
程序员/n, (, 英文/nz, programmer/en, ), 是/v, 从事/v, 程序/n, 开发/v, 、/w, 维护/v, 的/uj, 专业/n, 人员/n, 。/w, 
一般/a, 将/d, 程序员/n, 分为/v, 程序/n, 设计/vn, 人员/n, 和/c, 程序/n, 编码/n, 人员/n, ，/w, 但/c, 两者/r, 的/uj, 界限/n, 并/c, 不/d, 非常/d, 清楚/a, ，/w, 特别/d, 是/v, 在/p, 中国/ns, 。/w, 
软件/n, 从业/b, 人员/n, 分为/v, 初级/b, 程序员/n, 、/w, 高级/a, 程序员/n, 、/w, 系统/n, 分析员/n, 和/c, 项目/n, 经理/n, 四/m, 大/a, 类/q, 。/w
```

然后去掉里面的停用词，这里我去掉了标点符号、常用词、以及名词、动词、形容词、副词之外的词。得出实际有用的词语：
```
程序员, 英文, 程序, 开发, 维护, 专业, 人员, 
程序员, 分为, 程序, 设计, 人员, 程序, 编码, 人员, 界限, 特别, 中国, 
软件, 人员, 分为, 程序员, 高级, 程序员, 系统, 分析员, 项目, 经理
```

建立两个大小为9(k=9)的窗口，每个单词将票投给它身前身后距离5以内的单词：
```
开发=[专业, 程序员, 维护, 英文, 程序, 人员]
软件=[程序员, 分为, 界限, 高级, 中国, 特别, 人员]
程序员=[开发, 软件, 分析员, 维护, 系统, 项目, 经理, 分为, 英文, 程序, 专业, 设计, 高级, 人员, 中国]
分析员=[程序员, 系统, 项目, 经理, 高级]
维护=[专业, 开发, 程序员, 分为, 英文, 程序, 人员]
系统=[程序员, 分析员, 项目, 经理, 分为, 高级]
项目=[程序员, 分析员, 系统, 经理, 高级]
经理=[程序员, 分析员, 系统, 项目]
分为=[专业, 软件, 设计, 程序员, 维护, 系统, 高级, 程序, 中国, 特别, 人员]
英文=[专业, 开发, 程序员, 维护, 程序]
程序=[专业, 开发, 设计, 程序员, 编码, 维护, 界限, 分为, 英文, 特别, 人员]
特别=[软件, 编码, 分为, 界限, 程序, 中国, 人员]
专业=[开发, 程序员, 维护, 分为, 英文, 程序, 人员]
设计=[程序员, 编码, 分为, 程序, 人员]
编码=[设计, 界限, 程序, 中国, 特别, 人员]
界限=[软件, 编码, 程序, 中国, 特别, 人员]
高级=[程序员, 软件, 分析员, 系统, 项目, 分为, 人员]
中国=[程序员, 软件, 编码, 分为, 界限, 特别, 人员]
人员=[开发, 程序员, 软件, 维护, 分为, 程序, 特别, 专业, 设计, 编码, 界限, 高级, 中国]
```

然后开始迭代投票，直至收敛。对权重进行倒序排序，从而得到最重要的N个单词，作为候选关键词。在原始文本中进行标记，若形成相邻词组，则组合成多词关键词。

## TextRank提取摘要
基于TextRank的自动文摘属于自动摘录，通过选取文本中重要度较高的句子形成文摘，其主要步骤如下：

1. 预处理：将输入的文本或文本集的内容分割成句子得`T = [S_1, S_2, .., S_m]`，构建图`G = (V, E)`，其中V为句子集，对句子进行分词、去除停止词，得`S_i = [t_i1, t_i2, .., t_in]`。
2. 句子相似度：构建图G中的边集E，基于句子间的内容覆盖率，给定两个句子`S_i`和`S_j`，计算公式：$Similarity(S_i, S_j) = \frac{|\{w_k|w_k \in S_i \& w_k \in S_j\}|}{log(|S_i|) + log(|S_j|)}$，分子是在两个句子中都出现的单词的数量。`|S_i|`是句子i的单词数。其它计算相似度的方法有：基于编辑距离，基于语义词典，余弦相似度，BM25等。
3. 句子权重：根据公式，迭代传播权重计算各句子的得分。
4. 抽取文摘句：将（3）得到的句子得分进行倒序排序，抽取重要度最高的N个句子作为候选文摘句。
5. 形成文摘：根据字数或句子数要求，从候选文摘句中抽取句子组成文摘。

## 参考资料：
- [TextRank自动文摘](http://www.cnblogs.com/chenbjin/p/4600538.html)
- [TextRank算法自动摘要的Java实现](http://www.hankcs.com/nlp/textrank-algorithm-java-implementation-of-automatic-abstract.html)
- [TextRank算法提取关键词的Java实现](http://www.hankcs.com/nlp/textrank-algorithm-to-extract-the-keywords-java-implementation.html)